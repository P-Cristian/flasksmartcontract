<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardGameShop App</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
</head>
<body>
    <h1>BoardGameShop App</h1>

    <div id="connection-status"></div>

    <h2>Add Game</h2>
    <input type="text" id="addTitle" placeholder="Title">
    <input type="text" id="addDescription" placeholder="Description">
    <input type="number" id="addPrice" placeholder="Price">
    <button onclick="addGame()">Add Game</button>

    <h2>Update Game</h2>
<input type="number" id="updateGameId" placeholder="Game ID">
<input type="text" id="updateTitle" placeholder="New Title">
<input type="text" id="updateDescription" placeholder="New Description">
<input type="number" id="updatePrice" placeholder="New Price">
<label>
    For Sale
    <input type="checkbox" id="updateIsForSale">
</label>
<button onclick="updateGame()">Update Game</button>

    <h2>Buy Game</h2>
    <div id="game-list"></div>

    <h2>Remove Game</h2>
    <input type="text" id="removeGameId" placeholder="Game Name">
    <button onclick="removeGame()">Remove Game</button>

    <h2>Bought Games</h2>
    <button onclick="getBoughtGames()">Refresh Bought Games</button>
    <div id="boughtGamesList"></div>

    <script>
        let web3;
        let contract;
        let account;

        async function connectMetaMask() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    web3 = new Web3(window.ethereum);
                    const accounts = await web3.eth.getAccounts();
                    account = accounts[0];
                    document.getElementById('connection-status').innerText = 'Connected: ' + account;

                    const contractAddress = '{{ contract_address }}';
                    const contractABI = {{ contract_abi|tojson }};
                    contract = new web3.eth.Contract(contractABI, contractAddress);
                    await getGames();
                } catch (error) {
                    console.error('User denied account access');
                }
            } else {
                console.log('MetaMask not detected');
            }
        }

        async function addGame() {
    const title = document.getElementById('addTitle').value;
    const description = document.getElementById('addDescription').value;
    const price = document.getElementById('addPrice').value;

    console.log(`Adding game: Title=${title}, Description=${description}, Price=${price}`);

    try {
        await contract.methods.addGame(title, description, web3.utils.toWei(price, 'ether')).send({
            from: account,
            gas: 3000000 // Provide enough gas
        });
        alert('Game added successfully!');
        await getGames();
        displayGames();
    } catch (error) {
        console.error('Error adding game:', error);
        alert('Error adding game. Check console for details.');
    }
}
async function updateGame() {
    const gameId = document.getElementById('updateGameId').value;
    const title = document.getElementById('updateTitle').value;
    const description = document.getElementById('updateDescription').value;
    const price = document.getElementById('updatePrice').value;
    const isForSale = document.getElementById('updateIsForSale').checked;

    console.log(`Updating game: ID=${gameId}, Title=${title}, Description=${description}, Price=${price}, For Sale=${isForSale}`);

    try {
        const game = await contract.methods.getGame(gameId).call();
        console.log('Current account:', account);
        console.log('Game owner:', game[3]);

        const owner = game[3];

        if (owner.toLowerCase() !== account.toLowerCase()) {
            throw new Error("Only the owner can update the game");
        }

        await contract.methods.updateGame(gameId, title, description, web3.utils.toWei(price, 'ether'), isForSale).send({
            from: account,
            gas: 3000000 // Provide enough gas
        });
        alert('Game updated successfully!');
        await getGames();
    } catch (error) {
        console.error('Error updating game:', error);
        alert('Error updating game. Check console for details.');
    }
}
async function buyGame(gameId) {
    const game = await contract.methods.getGame(gameId).call();
    const price = game[2];
    const buyer = (await web3.eth.getAccounts())[0];

    await contract.methods.buyGame(gameId).send({
        from: buyer,
        value: price
    });

    alert("Game purchased successfully");
    displayGames(); // Refresh game list after purchase
}

async function removeGame() {
    try {
        const accounts = await web3.eth.getAccounts();
        const account = accounts[0];
        console.log(account);
        const gameId = document.getElementById('removeGameId').value;
        console.log(gameId);
        const game = await contract.methods.getGameByName(gameId).call();
        console.log(game);
        console.log('Current account:', account);
        console.log('Game owner:', game[3]);

        const owner = game[3];

        if (owner.toLowerCase() !== account.toLowerCase()) {
            throw new Error("Only the owner can update the game");
        }

        await contract.methods.removeGame(gameId).send({ from: account });
        alert("Game removed successfully");
        displayGames(); // Refresh game list after removal
    } catch (error) {
        console.error("Error removing game: ", error);
    }
}

async function getGames() {
    try {
        const totalGames = await contract.methods.totalGames().call();
        const games = [];
        for (let i = 0; i < totalGames; i++) {
            const game = await contract.methods.getGame(i).call();
            games.push({
                id: i,
                title: game[0],
                description: game[1],
                price: game[2],
                owner: game[3],
                isForSale: game[4]
            });
        }
        return games;
    } catch (error) {
        console.error("Error fetching games: ", error);
    }
}

async function displayGames() {
    const games = await getGames(); 
    const gameList = document.getElementById('game-list');
    gameList.innerHTML = '';

    games.forEach(game => {
        if (game.title && game.isForSale) {
            const gameItem = document.createElement('li');

            // Game details
            gameItem.textContent = `${game.title} - ${game.description} - ${web3.utils.fromWei(game.price, 'ether')} ETH`; 

            // Buy button
            const buyButton = document.createElement('button');
            buyButton.textContent = 'Buy';
            buyButton.addEventListener('click', () => buyGame(game.title, game.price)); // Pass title and price
            gameItem.appendChild(buyButton);

            gameList.appendChild(gameItem);
        }
    });

    // If no games match the filter, display a message
    if (gameList.children.length === 0) {
        const noGamesMessage = document.createElement('li');
        noGamesMessage.textContent = "No games for sale at this time.";
        gameList.appendChild(noGamesMessage);
    }
}
        async function getBoughtGames() {
            const response = await fetch('/get_bought_games');
            const games = await response.json();
            const boughtGamesList = document.getElementById('boughtGamesList');
            boughtGamesList.innerHTML = '';
            games.forEach(game => {
                boughtGamesList.innerHTML += `<p>Game ID: ${game.game_id}, Buyer: ${game.buyer}</p>`;
            });
        }

        connectMetaMask();
    </script>
</body>
</html>