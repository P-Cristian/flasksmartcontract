<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardGameShop App</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
</head>
<body>
    <h1>BoardGameShop App</h1>

    <div id="connection-status"></div>

    <h2>Add Game</h2>
    <input type="text" id="addTitle" placeholder="Title">
    <input type="text" id="addDescription" placeholder="Description">
    <input type="number" id="addPrice" placeholder="Price">
    <button onclick="addGame()">Add Game</button>

    <h2>Update Game</h2>
<input type="number" id="updateGameId" placeholder="Game ID">
<input type="text" id="updateTitle" placeholder="New Title">
<input type="text" id="updateDescription" placeholder="New Description">
<input type="number" id="updatePrice" placeholder="New Price">
<label>
    For Sale
    <input type="checkbox" id="updateIsForSale">
</label>
<button onclick="updateGame()">Update Game</button>

    <h2>Buy Game</h2>
    <div id="game-list"></div>

    <h2>Remove Game</h2>
    <input type="text" id="removeGameId" placeholder="Game Name">
    <button onclick="removeGame()">Remove Game</button>

    <h2>Bought Games</h2>
    <button onclick="getBoughtGames()">Refresh Bought Games</button>
    <div id="boughtGamesList"></div>

    <script>
        let web3;
        let contract;
        let account;

        async function connectMetaMask() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    web3 = new Web3(window.ethereum);
                    const accounts = await web3.eth.getAccounts();
                    account = accounts[0];
                    document.getElementById('connection-status').innerText = 'Connected: ' + account;

                    const contractAddress = '{{ contract_address }}';
                    const contractABI = {{ contract_abi|tojson }};
                    contract = new web3.eth.Contract(contractABI, contractAddress);
                    await getGames();
                    displayGames();
                } catch (error) {
                    console.error('User denied account access');
                }
            } else {
                console.log('MetaMask not detected');
            }
        }

        async function addGame() {
    const title = document.getElementById('addTitle').value;
    const description = document.getElementById('addDescription').value;
    const price = document.getElementById('addPrice').value;

    console.log(`Adding game: Title=${title}, Description=${description}, Price=${price}`);

    try {
        await contract.methods.addGame(title, description, web3.utils.toWei(price, 'ether')).send({
            from: account,
            gas: 3000000 
        });
        alert('Game added successfully!');
        await getGames();
        displayGames();
    } catch (error) {
        console.error('Error adding game:', error);
        alert('Error adding game. Check console for details.');
    }
}
async function updateGame() {
    const gameId = document.getElementById('updateGameId').value;
    const title = document.getElementById('updateTitle').value;
    const description = document.getElementById('updateDescription').value;
    const price = document.getElementById('updatePrice').value;
    const isForSale = document.getElementById('updateIsForSale').checked;

    console.log(`Updating game: ID=${gameId}, Title=${title}, Description=${description}, Price=${price}, For Sale=${isForSale}`);

    try {
        const game = await contract.methods.getGame(gameId).call();
        console.log('Current account:', account);
        console.log('Game owner:', game[3]);

        const owner = game[3];

        if (owner.toLowerCase() !== account.toLowerCase()) {
            throw new Error("Only the owner can update the game");
        }

        await contract.methods.updateGame(gameId, title, description, web3.utils.toWei(price, 'ether'), isForSale).send({
            from: account,
            gas: 3000000 
        });
        alert('Game updated successfully!');
        await getGames();
        displayGames();
    } catch (error) {
        console.error('Error updating game:', error);
        alert('Error updating game. Check console for details.');
    }
}
async function buyGame(gameTitle) {
    try {
        const game = await contract.methods.getGameByName(gameTitle).call();
        const gasEstimate = await contract.methods.buyGame(gameTitle).estimateGas({
            from: account,
            value: game.price
        });
        console.log(gameTitle);
        await contract.methods.buyGame(gameTitle).send({
            from: account,
            value: game.price,
            gas: gasEstimate
        });
        try {
                    const response = await fetch('/write_game', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ gameTitle: game.title }),
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to write game to file');
                    }
                    
                    console.log('Game title written to file successfully');
                } catch (writeError) {
                    console.error('Error writing game to file:', writeError);
                }
        contract.events.GameBought({ filter: {}, fromBlock: 'latest' }, async (error, event) => {
            if (!error) {
                alert(`You bought ${game.title}!`);
                
              
                
                
                displayGames(); 
            } else {
                console.error(error);
            }
        });
        displayGames(); 
    } catch (error) {
        console.error("Error buying game:", error);
        if (error.code === 4001) { 
            alert('Transaction rejected');
        } else {
            alert('Error buying game. See console for details.');
        }
    }
}

async function removeGame() {
    try {
        const accounts = await web3.eth.getAccounts();
        const account = accounts[0];
        console.log(account);
        const gameId = document.getElementById('removeGameId').value;
        console.log(gameId);
        const game = await contract.methods.getGameByName(gameId).call();
        console.log(game);
        console.log('Current account:', account);
        console.log('Game owner:', game[3]);

        const owner = game[3];

        if (owner.toLowerCase() !== account.toLowerCase()) {
            throw new Error("Only the owner can update the game");
        }

        await contract.methods.removeGame(gameId).send({ from: account });
        alert("Game removed successfully");
        displayGames(); 
    } catch (error) {
        console.error("Error removing game: ", error);
    }
}

async function getGames() {
    try {
        const totalGames = await contract.methods.totalGames().call();
        const games = [];
        for (let i = 0; i < totalGames; i++) {
            const game = await contract.methods.getGame(i).call();
            games.push({
                id: i,
                title: game[0],
                description: game[1],
                price: game[2],
                owner: game[3],
                isForSale: game[4]
            });
        }
        return games;
    } catch (error) {
        console.error("Error fetching games: ", error);
    }
}

async function displayGames() {
    const games = await getGames(); 
    const gameList = document.getElementById('game-list');
    gameList.innerHTML = '';

    games.forEach(game => {
        if (game.title && game.isForSale ) {
            const gameItem = document.createElement('li');

            
            gameItem.innerHTML = `
                ${game.title} - ${game.description} - 
                <span class="game-price">${web3.utils.fromWei(game.price, 'ether')}</span> ETH
            `;

           
            const buyButton = document.createElement('button');
            buyButton.textContent = 'Buy';
            buyButton.addEventListener('click', () => {
                const priceSpan = gameItem.querySelector('.game-price');
                const priceInEther = priceSpan.textContent;
                buyGame(game.title, web3.utils.toWei(priceInEther, 'ether')); 
            });
            gameItem.appendChild(buyButton);

            gameList.appendChild(gameItem);
        }
    });

    
    if (gameList.children.length === 0) {
        const noGamesMessage = document.createElement('li');
        noGamesMessage.textContent = "No games for sale at this time.";
        gameList.appendChild(noGamesMessage);
    }
}
async function getBoughtGames() {
    try {
        const response = await fetch('/get_bought_games');
        const titles = await response.json();
        const boughtGamesList = document.getElementById('boughtGamesList');
        boughtGamesList.innerHTML = '';
        titles.forEach(title => {
            boughtGamesList.innerHTML += `<p>${title}</p>`;
        });
    } catch (error) {
        console.error('Error fetching bought games:', error);
        const boughtGamesList = document.getElementById('boughtGamesList');
        boughtGamesList.innerHTML = '<p>Error loading bought games</p>';
    }
}

        connectMetaMask();
    </script>
</body>
</html>